from multiplierz.mzAPI import mzFile
from multiplierz.mzReport import reader, writer
from multiplierz.internalAlgorithms import collectByCriterion
from gui import BasicTab

import wx
from numpy import sqrt
from collections import defaultdict



import matplotlib
from matplotlib.figure import Figure

matplotlib.use('WXAgg')
from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas


tolerance = 0.01
largenum = 3000 # Doesn't get much larger than that, right?


class plotState(object):
    def __init__(self, ax, data):
        self.ax = ax
        self.data = data
        
        self._mode = None # 'xic' or 'scan'
                
        self._rtspan = None
        self._mzwidth = None
      
        self._scan = None
        self._mzspan = None # 'scan' extent
        self.centroid = True
        
        self.annotations = []
        self.zoomstack = []
      
        
        # This data is generated by the object from the mzFile instance; unsettable.
        # These are is kept as a cache to avoid unnecessary mzFile accessses.
        self._xicdata = None  
        self._scandata = None
        
    
    @property
    def mode(self):
        return self._mode
    @mode.setter
    def mode(self, mode):
        if mode != self.mode:
            if mode == 'xic':
                self.scan = None
                self.mzspan = None
                self.centroid = True
                self._scandata = []
            elif mode == 'scan':
                self.mzwidth = None
                self.rtspan = None
                self._xicdata = []
            else:
                raise NotImplementedError, "Invalid mode: %s" % mode
            self.zoomstack = []
            self._mode = mode
    
    @property
    def mzwidth(self):
        return self._mzwidth
    @mzwidth.setter
    def mzwidth(self, width):
        if width != self._mzwidth:
            self._mzwidth = width
            self._xicdata = None
        
    @property
    def scan(self):
        return self._scan
    @scan.setter
    def scan(self, scanNum):
        if scanNum:
            print "Generating scan."
            self._scandata = self.data.scan(scanNum, centroid = self.centroid)
        self._scan = scanNum
        
        
    @property        
    def xic_data(self):
        if (self._xicdata and
            self._xicdata[0][0] <= self.rtspan[0] and self._xicdata[-1][0] >= self.rtspan[1]):
            return [x for x in self._xicdata if self.rtspan[0] <= x[0] <= self.rtspan[1]]
        else:
            print "Generating XIC."
            xic = self.data.xic(*self.rtspan + self._mzwidth)
            self._rtspan = xic[0][0], xic[-1][0]
            self._xicdata = xic
            return xic
    
    @property
    def scan_data(self):
        # Presuming scanNum was set, there should be valid scan data.
        return [x for x in self._scandata if self.mzspan[0] <= x[0] <= self.mzspan[1]]
    
    
    @property
    def mzspan(self):
        return self._mzspan
    @mzspan.setter
    def mzspan(self, span):
        self.zoomstack.append(span)
        self._mzspan = span
        
    @property
    def rtspan(self):
        return self._rtspan
    @rtspan.setter
    def rtspan(self, span):
        self.zoomstack.append(span)
        self._rtspan = span
    
        



class InterfacePlot(wx.Panel):
    def __init__(self, parent, ident = -1):
        wx.Panel.__init__(self, parent, ident, size = (100, 100))
        # Why does "size = (100, 100)" make the size adapt correctly?
        # It is a mystery!
        
        self.fig = Figure()
        self.ax1 = self.fig.add_subplot(211)
        self.ax2 = self.fig.add_subplot(212)
        self.ax1.get_yaxis().set_tick_params(which='both', direction='in')
        #self.ax.yaxis.set_visible(False)
        #self.ax.xaxis.set_visible(False)
        #self.ax.yaxis.get_major_formatter().set_powerlimits((-1, 3))
        #self.fig.tight_layout(h_pad = 1)
        #self.fig.tight_layout(pad = 0, rect = [0.005, 0.1, 1, 0.95])
        self.fig.tight_layout(pad = 0, h_pad = 0, w_pad = 0)
        
        
        self.canvas = FigureCanvas(self, -1, self.fig)
        
        wxbackground = wx.SystemSettings.GetColour(wx.SYS_COLOUR_BTNFACE)
        wxbackground = [x / 255.0 for x in wxbackground]
        self.fig.set_facecolor(wxbackground)
        #self.fig.set_facecolor((0.5, 0.5, 0.5))
        
        self.sizer = wx.BoxSizer()
        self.sizer.Add(self.canvas, -1, wx.EXPAND)
        self.SetSizer(self.sizer)
        self.Fit()
        
        self.clickBack = self.canvas.mpl_connect('button_press_event', self.mouseClick)
        self.releaseBack = self.canvas.mpl_connect('button_release_event', self.mouseRelease)
        
        self.ax1.yaxis.get_major_formatter().set_powerlimits((-1, 3))
        self.ax1.xaxis.get_major_formatter().set_powerlimits((-5, 10))        
        self.ax2.yaxis.get_major_formatter().set_powerlimits((-1, 3))
        self.ax2.xaxis.get_major_formatter().set_powerlimits((-5, 10))        
        
        self.canvas.draw()
        
        self.states = None
        self.data = None

        self.clickax = None
        self.rightclick = self.leftclick = None
        self.rightclickpixel = self.leftclickpixel = None
        
    
    def setData(self, data, scanCallback):
        self.states = {self.ax1 : plotState(self.ax1, data), 
                       self.ax2 : plotState(self.ax2, data)}
    
        self.data = data
        self.commissionDefaultPlot()
        self.scanback = scanCallback

        self.ax1.cla()
        self.ax2.cla()
    
        
        self.ms1lookup = {}
        self.mzlookup = {}
        self.ms1set = set()
        prev = None
        for rt, mz, scanNum, level, _ in self.data.scan_info(0, 999999):
            if level == 'MS1':
                prev = scanNum
                self.ms1set.add(scanNum)
            else:
                self.mzlookup[scanNum] = mz
                self.ms1lookup[scanNum] = prev
        
        
    def commissionDefaultPlot(self):
        topstate = self.states[self.ax1]
        
        topstate.mode = 'xic'
        topstate.rtspan = self.data.time_range()
        topstate.mzwidth = 0, largenum
        topstate.annotations = []
        
        self.displayXIC(topstate)
        self.ax2.cla()
        
    def commissionPSMPlot(self, MS2, MZ, centroid = True):
        # I suppose a full XIC is expedient; why not?
        
        rt = self.data.timeForScan(MS2)
        #ms1 = self.ms1lookup[MS2]
        
        topstate = self.states[self.ax1]
        botstate = self.states[self.ax2]
        
        topstate.mode = 'xic'
        topstate.rtspan = self.data.time_range()
        topstate.mzwidth = MZ - tolerance, MZ + tolerance
        topstate.annotations = [x for x in topstate.annotations if x[0] != 'currentscan']
        topstate.annotations.append(('currentscan', 'pin', rt, {'color':'r', 'linestyle':'--'}))
        
        botstate.mode = 'scan'
        botstate.mzspan = 0, largenum
        botstate.scan = MS2
        botstate.centroid = centroid
        botstate.annotations = [('precursor', 'pin', MZ, {'color':'r', 'linestyle':'--'})]        
        
        self.updatePlots()
        
    def commissionScanDisplay(self, scanNum, mz = None, centroid = True):
        rt = self.data.timeForScan(scanNum)
        
        topstate = self.states[self.ax1]
        botstate = self.states[self.ax2]
        
        topstate.mode = 'xic'
        topstate.rtspan = self.data.time_range()
        if (not mz) and scanNum in self.mzlookup:
            mz = self.mzlookup[scanNum]
            if mz > 0: # If its MS1.
                topstate.mzwidth = mz - tolerance, mz + tolerance
            else:
                topstate.mzwidth = 0, largenum
        else:
            mz = None
            topstate.mzwidth = 0, 2000
        topstate.annotations = [x for x in topstate.annotations if x[0] != 'currentscan']
        topstate.annotations.append(('currentscan', 'pin', rt, {'color':'r', 'linestyle':'--'}))
        
        botstate.mode = 'scan'
        botstate.mzspan = 0, largenum
        botstate.scan = scanNum
        botstate.centroid = centroid
        if mz:
            botstate.annotations = [('precursor', 'pin', mz, {'color':'r', 'linestyle':'--'})]
        else:
            botstate.annotations = []
            
        self.updatePlots()
        

    
    def zoom(self, ax, newxspan, newyspan):
        state = self.states[ax]
        if state.mode == 'xic':
            state.rtspan = newxspan
        elif state.mode == 'scan':
            state.mzspan = newxspan
        # y-span is unused; automatically adapts from new plot.  Good enough for Xcalibur.
        self.updatePlots()
            
    
    def unzoom(self, ax):
        state = self.states[ax]
        oldspan = state.zoomstack.pop()
        try:
            newxspan = state.zoomstack.pop()
            if state.mode == 'xic':
                state.rtspan = newxspan
            elif state.mode == 'scan':
                state.mzspan = newxspan
            self.updatePlots()
        except IndexError:
            state.zoomstack.append(oldspan)
            
      
    def selectScan(self, xicax, scanax, rt, centroid = True):
        xicstate = self.states[xicax]
        scanstate = self.states[scanax]
        assert xicstate.mode == 'xic', "What?"
        scanstate.mode = 'scan'
        
        xicstate.annotations = [('currentscan', 'pin', rt, {'color':'r', 'linestyle':'--'})]
        
        scanNum = self.data.scanForTime(rt)
        scanstate.scan = scanNum
        scanstate.mzspan = 0, largenum
        scanstate.centroid = centroid
        scanstate.annotations = []
        
        self.scanback(scanNum)
        self.updatePlots()
        
        
         
            
    def updatePlots(self):
        for state in self.states.values():
            if state.mode == 'xic':
                self.displayXIC(state)
            elif state.mode == 'scan':
                self.displaySpectrum(state)
            
    
    def displayXIC(self, state):
        assert state.mode == 'xic'
        
        ax = state.ax
        ax.cla()
        
        xic = state.xic_data
        ax.plot(zip(*xic)[0], zip(*xic)[1], color = 'k')
        
        bot, top = ax.get_ylim()
        left, right = ax.get_xlim()
        for _, thing, position, appearance in state.annotations:
            if thing == 'pin':
                ax.vlines([position], [bot], [top], **appearance)
            elif thing == 'range':
                ax.axvspan(*position, **appearance)
            else:
                print "Unrecognized thing: %s" % thing
        ax.set_ylim(bot, top)
        ax.set_xlim(*state.rtspan)
        
        left, right = state.rtspan
        labelcoord = right - ((right-left)/100), top*0.99
        ax.text(labelcoord[0], labelcoord[1],
                "XIC RT[%.2f - %.2f] MZ[%.2f - %.2f]" % (left, right,
                                                         state.mzwidth[0], state.mzwidth[1]),
                horizontalalignment = 'right', verticalalignment = 'top', color = 'b')        
        
        self.canvas.draw()
        
    
    def displaySpectrum(self, state):
        ax = state.ax
        ax.cla()
        assert state.mode == 'scan'
        
        scan = state.scan_data
        if scan:
            ax.vlines(zip(*scan)[0], [0] * len(scan), zip(*scan)[1])
        else:
            print "Empty scan."
        
        bot, top = ax.get_ylim()
        left, right = ax.get_xlim()
        for _, thing, position, color in state.annotations:
            if thing == 'pin':
                ax.vlines([position], [bot], [top], **color)
            elif thing == 'range':
                ax.axvspan(*position + color)
            else:
                print "Unrecognized thing: %s" % thing
        ax.set_ylim(0, top)
        if state.mzspan[1] != largenum:
            #ax.set_xlim(state.mzspan)
            left, right = state.mzspan
        else:
            left = state.mzspan[0]
            rightmost = scan[-1][0]
            right = rightmost + ((rightmost - left) / 10)
        
        labelcoord = right - ((right-left)/100), top*0.99
        scantype = 'MS2' if state.scan in self.ms1lookup else 'MS1'
        if scantype == 'MS2':
            prec = self.mzlookup[state.scan]
            ax.text(labelcoord[0], labelcoord[1],
                    "%s Scan %d at MZ %.2f (%.2f - %.2f)" % (scantype, state.scan, prec, left, right),
                    horizontalalignment = 'right', verticalalignment = 'top', color = 'b')
            ax.vlines([prec], [bot], [top], linestyle = '--', color = 'r')
        else:
            ax.text(labelcoord[0], labelcoord[1],
                    "%s Scan %d (%.2f - %.2f)" % (scantype, state.scan, left, right),
                    horizontalalignment = 'right', verticalalignment = 'top', color = 'b')            
        
        ax.set_xlim(left, right)
        
        self.canvas.draw()    
        
    
    def mouseClick(self, event):
        button = event.button
        ax = event.inaxes
        if not ax:
            print "Out of bounds."
            return
        
        print button, ax
        if button == 1:
            self.leftclick = event.xdata, event.ydata
            self.leftclickpixel = event.x, event.y
            self.clickax = ax
        elif button == 3:
            self.rightclick = event.xdata, event.ydata
            self.rightclickpixel = event.x, event.y
            self.clickax = ax
            
    
    def mouseRelease(self, event):
        if not self.clickax:
            return        
        button = event.button
        ax = event.inaxes       
        if not ax == self.clickax:
            self.clickax = None
            self.rightclick = self.leftclick = None
            self.rightclickpixel = self.leftclickpixel = None     
            return
        

        def euclidean(first, second):
            return sqrt((first[0] - second[0])**2 + (first[1] - second[1])**2)
        
        if button == 1:
            pixel = event.x, event.y
            distance = euclidean(pixel, self.leftclickpixel)
            if distance > 5:
                # Zoom on current graph.
                
                top = max(event.ydata, self.leftclick[1])
                bot = 0
                left = min(event.xdata, self.leftclick[0])
                right = max(event.xdata, self.leftclick[0])
                
                print 'Zoom'
                self.zoom(ax, (left, right), None)
            
            elif self.states[ax].mode == 'xic':
                # Display scan at selected RT.
                otherAx = [x for x in self.states.keys() if x != ax][0]
                print 'Select'
                self.selectScan(ax, otherAx, event.xdata)
        
        elif button == 3:
            print 'Unzoom'
            self.unzoom(ax)
                
                    
    def resetXICRT(self, *etc):
        for state in self.states.values():
            if state.mode == 'xic':
                state.rtspan = state.data.time_range()
                self.displayXIC(state)
    
    def resetXICMZ(self, *etc):
        for state in self.states.values():
            if state.mode == 'xic':
                state.mzwidth = 0, largenum
                self.displayXIC(state)
            
        
    
    


class ViewPanel(BasicTab):
    def __init__(self, parent, id = -1):
        wx.Panel.__init__(self, parent, id)
        
        self.set_status("Initializing...", 0)
        self.set_status("", 1)
        
        self.entrySelector = wx.TreeCtrl(self, -1, size = (350, -1),
                                         style = wx.TR_LINES_AT_ROOT | wx.TR_HIDE_ROOT | wx.TR_TWIST_BUTTONS | wx.TR_HAS_BUTTONS)
        self.Bind(wx.EVT_TREE_SEL_CHANGED, self.displayPeptide, self.entrySelector)
        self.display = InterfacePlot(self, -1)
        #self.spectraPlot = InterfacePlot(self, -1)
        
        #self.Bind(EVT_InterfaceClick, self.displayClick, self.display)
        
        self.dataLabel = wx.StaticText(self, -1, "MS Data File")
        self.dataCtrl = wx.TextCtrl(self, -1)
        self.dataButton = wx.Button(self, -1, "Browse")
        self.resultLabel = wx.StaticText(self, -1, "PSM File")
        self.resultCtrl = wx.TextCtrl(self, -1)
        self.resultButton = wx.Button(self, -1, "Browse")
        
        self.Bind(wx.EVT_BUTTON, self.dataBrowse, self.dataButton)
        self.Bind(wx.EVT_BUTTON, self.resultBrowse, self.resultButton)
        
        self.searchCtrl = wx.TextCtrl(self, -1, style = wx.TE_PROCESS_ENTER)
        self.searchSelect = wx.ComboBox(self, -1, choices = ['Accession', 'Peptide'])
        self.searchButton = wx.Button(self, -1, "Filter")

        self.Bind(wx.EVT_BUTTON, self.updatePSMDisplay, self.searchButton)
        
        self.widenXIC = wx.Button(self, -1, "Reset XIC MZ Range")
        self.resetXIC = wx.Button(self, -1, "Reset XIC RT Range")
        
        self.Bind(wx.EVT_BUTTON, self.display.resetXICMZ, self.widenXIC)
        self.Bind(wx.EVT_BUTTON, self.display.resetXICRT, self.resetXIC)
        
        self.prevMS1 = wx.Button(self, -1, "Prev MS1")
        self.prevScan = wx.Button(self, -1, "<")
        self.scanCtrl = wx.TextCtrl(self, -1, style = wx.TE_PROCESS_ENTER | wx.TE_CENTRE)
        self.nextScan = wx.Button(self, -1, ">")
        self.nextMS1 = wx.Button(self, -1, "Next MS1")
        
        self.Bind(wx.EVT_BUTTON, self.decScan, self.prevScan)
        self.Bind(wx.EVT_BUTTON, self.incScan, self.nextScan)
        self.Bind(wx.EVT_BUTTON, self.decMS1, self.prevMS1)
        self.Bind(wx.EVT_BUTTON, self.incMS1, self.nextMS1)
        self.Bind(wx.EVT_TEXT_ENTER, self.scanUpdated, self.scanCtrl)
        
        self.gbs = wx.GridBagSizer(5, 5)
        controlBox = wx.GridBagSizer(5, 5)
        searchBox = wx.GridBagSizer(5, 5)
        selectorBox = wx.GridBagSizer(5, 5)
        controlBox.Add(self.dataLabel, (0, 0), flag = wx.ALIGN_RIGHT)
        controlBox.Add(self.dataCtrl, (0, 1), flag = wx.EXPAND)
        controlBox.Add(self.dataButton, (0, 2), flag = wx.ALIGN_LEFT)
        controlBox.Add(self.resultLabel, (1, 0), flag = wx.ALIGN_RIGHT)
        controlBox.Add(self.resultCtrl, (1, 1), flag = wx.EXPAND)
        controlBox.Add(self.resultButton, (1, 2), flag = wx.ALIGN_LEFT)
        controlBox.AddGrowableCol(1)
        
        searchBox.Add(self.searchCtrl, (0, 0), flag = wx.EXPAND)
        searchBox.Add(self.searchSelect, (0, 1), flag = wx.ALIGN_RIGHT)
        searchBox.Add(self.searchButton, (0, 2), flag = wx.ALIGN_LEFT)
        searchBox.AddGrowableCol(0)
        
        self.gbs.Add(controlBox, (0, 0), (1, 5), flag = wx.EXPAND)
        self.gbs.Add(searchBox, (1, 0), flag = wx.EXPAND)
        self.gbs.Add(self.entrySelector, (2, 0), span = (3, 1), flag = wx.EXPAND)
        self.gbs.Add(self.display, (1, 1), span = (2, 4), flag = wx.EXPAND)
        #self.gbs.Add(self.spectraPlot, (2, 1), span = (1, 4), flag = wx.EXPAND)
        self.gbs.AddGrowableCol(3)
        #self.gbs.AddGrowableRow(1)
        self.gbs.AddGrowableRow(2)
        
        selectorBox.Add(self.prevMS1, (0, 0), flag = wx.ALIGN_RIGHT)
        selectorBox.Add(self.prevScan, (0, 1), flag = wx.ALIGN_RIGHT)
        selectorBox.Add(self.scanCtrl, (0, 2), flag = wx.EXPAND)
        selectorBox.Add(self.nextScan, (0, 3), flag = wx.ALIGN_LEFT)
        selectorBox.Add(self.nextMS1, (0, 4), flag = wx.ALIGN_LEFT)
        selectorBox.Add(self.resetXIC, (0, 5), flag = wx.ALIGN_RIGHT)
        selectorBox.Add(self.widenXIC, (0, 6), flag = wx.ALIGN_LEFT)  
        selectorBox.AddGrowableCol(0)
        selectorBox.AddGrowableCol(5)
        self.gbs.Add(selectorBox, (3, 1), span = (1, 4), flag = wx.EXPAND | wx.ALIGN_RIGHT)


        overBox = wx.BoxSizer()
        overBox.Add(self.gbs, 1, wx.ALL | wx.EXPAND, 20)
        self.SetSizerAndFit(overBox)
        
        self.data = None
        self.psms = None        
        self.manageSizes()  
        

        
        
        
        
    def manageSizes(self):
        # If there's PSM data to display, the entrySelector should be visible
        # to display it; otherwise it should be minimized and hidden as well
        # as possible.
        
        self.entrySelector.SetSize(wx.Size(10, 10))
        self.Refresh()
        #if self.psms:
            #print "FOO"
            #self.entrySelector.SetSize(wx.Size(100, -1))
        #else:
            #print "BAR"
            #self.entrySelector.SetSize(wx.Size(1, -1))
        #self.Update()
        
        
    def dataBrowse(self, event):
        filedialog = wx.FileDialog(parent = self, message = "Choose MS Data File",
                                   style = wx.FD_OPEN,
                                   wildcard = 'RAW|*.raw|WIFF|*.wiff|All|*.*')
        
        result = filedialog.ShowModal()
        if result == wx.ID_OK:
            newfile = filedialog.GetPath()
            self.dataCtrl.SetValue(newfile)
            self.openDataFile(event)
        else:
            print "Cancelled selection."
            
    def resultBrowse(self, event):
        filedialog = wx.FileDialog(parent = self, message = "Choose PSM File",
                                   style = wx.FD_OPEN,
                                   wildcard = 'XLSX|*.xlsx|XLS|*.xls|CSV|*.csv|All|*')
        
        result = filedialog.ShowModal()
        if result == wx.ID_OK:
            newfile = filedialog.GetPath()
            self.resultCtrl.SetValue(newfile)
            self.openResultFile(event)
        else:
            print "Cancelled selection."        
    
    def openDataFile(self, event):
        self.set_status("Opening MS data file...", 0)
        
        self.data = mzFile(self.dataCtrl.GetValue())
        
        self.display.setData(self.data, lambda x: self.scanCtrl.SetValue(str(x)))
        self.set_status("Ready.", 0)
        
    def openResultFile(self, event):
        self.set_status("Opening PSM file...", 0)
        
        reportfile = self.resultCtrl.GetValue()
        #self.psms = collectByCriterion(list(reader(reportfile)), lambda x: (x['Peptide Sequence'],
                                                                            #x['Variable Modifications'],
                                                                            #x['Charge']))
        results = list(reader(reportfile))
        proteinLabel = 'gene_symbol' if 'gene_symbol' in results[0] else 'Accession Number'
        #proteins = collectByCriterion(results, lambda x: x[proteinLabel])
        proteins = defaultdict(list)
        for psm in results:
            accessions = [x.strip() for x in psm[proteinLabel].split(';')]
            for accession in accessions:
                proteins[accession].append(psm)
                
        self.psms = {}
        for protein, psms in proteins.items():
            peptides = collectByCriterion(psms, lambda x: '|'.join([x['Peptide Sequence'],
                                                                   x['Variable Modifications'],
                                                                   str(x['Charge'])]))
            self.psms[protein] = peptides
        
        
        self.updatePSMDisplay(None)
        
        
    def updatePSMDisplay(self, event):
        self.wxMode = True
        self.entrySelector.DeleteAllItems()
        self.root = self.entrySelector.AddRoot('Foo')
        self.wxMode = False

        filterStr = self.searchCtrl.GetValue()
        filterType = self.searchSelect.GetStringSelection()

        visibleProteins = []
        for protein, peptides in self.psms.items():
            if filterType == 'Accession' and filterStr not in protein:
                continue
            
            visiblePeptides = []
            for peptide, psms in peptides.items():
                if filterType == 'Peptide' and filterStr not in peptide:
                    continue
                visiblePeptides.append((peptide, psms))
            
            if visiblePeptides:
                visibleProteins.append((protein, visiblePeptides))
        
        
        for protein, peptides in visibleProteins:
            protentry = self.entrySelector.AppendItem(self.root, protein)
            for peptide, psms in peptides:
                pepentry = self.entrySelector.AppendItem(protentry, peptide)
                for psm in psms:
                    psmTag = psm['Spectrum Description'].split('.')[1]
                    self.entrySelector.AppendItem(pepentry, psmTag)
        
        self.entrySelector.CollapseAll()
        
        self.set_status("Ready.", 0)
        
    
    
    def displayPeptide(self, event):
        if self.wxMode:
            return
        if not self.data:
            return
        
        root = self.entrySelector.GetRootItem()
        selection = self.entrySelector.GetSelection()
        descent = []
        while selection != root:
            descent.append(self.entrySelector.GetItemText(selection))
            selection = self.entrySelector.GetItemParent(selection)         
            
        if not descent:
            raise IOError
        
        print descent
        accession = descent[-1]
        if len(descent) > 1:
            peptide = descent[-2]
        else:
            peptide = None
        if len(descent) > 2:
            scan = descent[-3]
        else:
            scan = None        
    
        if scan:
            mz = self.psms[accession][peptide][0]['Experimental mz']
            self.display.commissionPSMPlot(int(scan), float(mz))
            self.scanCtrl.SetValue(str(scan))
            
        
    
    def decScan(self, event):
        scanNum = int(self.scanCtrl.GetValue()) - 1
        self.scanCtrl.SetValue(str(scanNum))
        self.display.commissionScanDisplay(scanNum) # What if this runs off the edge?
    def incScan(self, event):
        scanNum = int(self.scanCtrl.GetValue()) + 1
        self.scanCtrl.SetValue(str(scanNum))
        self.display.commissionScanDisplay(scanNum)
    def decMS1(self, event):
        scanNum = int(self.scanCtrl.GetValue())
        ms1 = max([x for x in self.display.ms1set if x < scanNum])
        self.scanCtrl.SetValue(str(ms1))
        self.display.commissionScanDisplay(ms1)
    def incMS1(self, event):
        scanNum = int(self.scanCtrl.GetValue())
        ms1 = min([x for x in self.display.ms1set if x > scanNum])
        self.scanCtrl.SetValue(str(ms1))
        self.display.commissionScanDisplay(ms1)  
    def scanUpdated(self, event):
        scanNum = int(self.scanCtrl.GetValue())
        self.display.commissionScanDisplay(scanNum)